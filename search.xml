<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ReactiveCocoa(一) 环境集成]]></title>
      <url>http://muluochenxi.com/2016/09/09/ReactiveCocoa-%E4%B8%80-%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>众所周知, <strong>ReactiveCocoa</strong> 是由 <strong>Github</strong> 工程师主导设计的一款 <strong>FRP</strong> 应用框架, 关于 <strong>RAC</strong> 和 <strong>FRP</strong> 在这里不再多作赘述。今天主要来介绍下RAC的引入。</p>
</blockquote>
<h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><ul>
<li>手动引入</li>
<li>CocoaPods</li>
<li>Carthage</li>
</ul>
<h2 id="引入前准备"><a href="#引入前准备" class="headerlink" title="引入前准备"></a>引入前准备</h2><p>本教程使用 <strong>Xcode 8</strong> 和 <strong>Xcode 7.3.1</strong> 同时讲解(因为Xcode8已经发布GM版本, 因此主要讲解Xcode8的适配工作)</p>
<p>新建工程 起名 <strong>RACImport</strong><br><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E5%B7%A5%E7%A8%8B%E5%88%9B%E5%BB%BA.png" alt="新建工程"></p>
<h2 id="手动引入"><a href="#手动引入" class="headerlink" title="手动引入"></a>手动引入</h2><p>在手动引入之前, 我们先来看看官方给出的引入流程。</p>
<p><img src="http://od88oby20.bkt.clouddn.com/img/rac/RAC%E5%AE%98%E6%96%B9%E5%AF%BC%E5%85%A5%E6%B5%81%E7%A8%8B2.png" alt="RAC官方导入流程"></p>
<h3 id="添加-ReactiveCocoa-的源到你的工程中-需要使用到-Git-子模块"><a href="#添加-ReactiveCocoa-的源到你的工程中-需要使用到-Git-子模块" class="headerlink" title="添加 ReactiveCocoa 的源到你的工程中, 需要使用到 Git 子模块"></a>添加 <strong>ReactiveCocoa</strong> 的源到你的工程中, 需要使用到 <strong>Git</strong> 子模块</h3><p>这里说到了添加 <strong>Git</strong> 子模块, 关于添加 <strong>Git</strong> 以及添加 <strong>Git</strong> 子模块在这都不作不详细赘述。<br>首先在工程目录中, 添加一个 <strong>Git</strong> 仓库:<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/git%E6%89%80%E6%94%BE%E7%9B%AE%E5%BD%95.png" alt="进入到工程目录中"><br>对应到终端<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E7%BB%88%E7%AB%AF%E8%BF%9B%E5%85%A5%E5%B7%A5%E7%A8%8B.png" alt="终端命令进入文件夹"></p>
<p>调用git初始化命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<p>显示初始化成功如下图</p>
<p><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="初始化"></p>
<p>然后调用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add https://github.com/ReactiveCocoa/ReactiveCocoa.git external/ReactiveCocoa</div></pre></td></tr></table></figure>
<p>开始下载 Git 子模块<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E5%88%9B%E5%BB%BA%E5%AD%90%E6%A8%A1%E5%9D%97.png" alt="下载子模块"></p>
<p>下载完毕后, 提示如下:<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E5%AD%90%E6%A8%A1%E5%9D%97%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%AF%95.png" alt="子模块下载完毕"></p>
<p>此时, 官方给出的导入步骤中的第一步完成</p>
<h3 id="运行子模块更新命令"><a href="#运行子模块更新命令" class="headerlink" title="运行子模块更新命令"></a>运行子模块更新命令</h3><p>执行以下代码, 更新子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E5%AD%90%E6%A8%A1%E5%9D%97%E6%9B%B4%E6%96%B0%E5%91%BD%E4%BB%A4.png" alt="运行命令后"></p>
<p>其中更新完成后, 会多出如下几个依赖库:</p>
<p><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%88%90%E5%AD%90%E6%A8%A1%E5%9D%97%E5%90%8E.png" alt="依赖库"></p>
<blockquote>
<p>注: 最新版本中添加了, <strong>ReactiveSwift</strong> , 并且支持 <strong>Xcode 8</strong></p>
</blockquote>
<h4 id="Xcode-8"><a href="#Xcode-8" class="headerlink" title="Xcode 8"></a>Xcode 8</h4><blockquote>
<p>注: 不需做任何操作</p>
</blockquote>
<h4 id="Xcode-7-3-1"><a href="#Xcode-7-3-1" class="headerlink" title="Xcode 7.3.1"></a>Xcode 7.3.1</h4><p>如果是 <strong>Xcode 7.3.1</strong> 需要注意, 工程中的 <strong>Result</strong> 和 <strong>ReactiveSwift</strong> 都是基于 <strong>Swift3</strong> 的。语法会有很大变化<br>因此, 需要从 <strong>Git</strong> 分支中, <strong>Checkout</strong> 出旧 <strong>tag</strong> 版本的 <strong>ReactiveCocoa</strong> 。<br>查看 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa Git仓库</a> 的 <strong>tag</strong> 找到 v4.2.2。</p>
<p>进入到 <strong>ReactiveCocoa</strong> 的目录<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/RAC%E6%A3%80%E5%87%BA%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>进入目录后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout v4.2.1</div></pre></td></tr></table></figure>
<p>然后查看工程目录中的 <strong>Cartfile</strong> 文件， 文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">github &quot;antitypical/Result&quot; ~&gt; 2.1.3</div></pre></td></tr></table></figure>
<p>接下来执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">carthage update</div></pre></td></tr></table></figure>
<p>执行过程如下图</p>
<p><img src="http://od88oby20.bkt.clouddn.com/img/rac/cartfile.png" alt=""></p>
<p>执行完成后, 此步骤完成</p>
<h3 id="拖拽-xcodeproj-文件到你的工程中"><a href="#拖拽-xcodeproj-文件到你的工程中" class="headerlink" title="拖拽 .xcodeproj 文件到你的工程中"></a>拖拽 .xcodeproj 文件到你的工程中</h3><h4 id="Xcode-8-1"><a href="#Xcode-8-1" class="headerlink" title="Xcode 8"></a>Xcode 8</h4><p>官方给出的文档中, 已经说明需要将 <code>ReactiveCocoa.xcodeproj</code>, <code>Carthage/Checkouts/ReactiveSwift/ReactiveSwift.xcodeproj</code>, and <code>Carthage/Checkouts/Result/Result.xcodeproj</code> 拖拽到你自己的工程中。 这三个文件相互依赖, 因此缺一不可。</p>
<p>在工程中创建一个 Group 起名 <strong>Frameworks</strong></p>
<h5 id="导入ReactiveCocoa-xcodeproj"><a href="#导入ReactiveCocoa-xcodeproj" class="headerlink" title="导入ReactiveCocoa.xcodeproj"></a>导入ReactiveCocoa.xcodeproj</h5><p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/%E5%AF%BC%E5%85%A5RAC.gif" alt="导入ReactiveCocoa.xcodeproj"></p>
<h5 id="导入ReactiveSwift-xcodeproj"><a href="#导入ReactiveSwift-xcodeproj" class="headerlink" title="导入ReactiveSwift.xcodeproj"></a>导入ReactiveSwift.xcodeproj</h5><p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/%E5%AF%BC%E5%85%A5RACSwift.gif" alt="导入ReactiveSwift.xcodeproj"></p>
<h5 id="导入Reuslt-xcodeproj"><a href="#导入Reuslt-xcodeproj" class="headerlink" title="导入Reuslt.xcodeproj"></a>导入Reuslt.xcodeproj</h5><p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/%E5%AF%BC%E5%85%A5Result.gif" alt="导入Result.xcodeproj"></p>
<h4 id="Xcode-7-3-1-1"><a href="#Xcode-7-3-1-1" class="headerlink" title="Xcode 7.3.1"></a>Xcode 7.3.1</h4><p>官方给出的文档中, 已经说明需要将 <code>ReactiveCocoa.xcodeproj</code> and <code>Carthage/Checkouts/Result/Result.xcodeproj</code> 拖拽到你自己的工程中。 ( <strong>Xcode 7.3.1</strong> 的版本中没有  <strong>ReactiveSwift.xcodeproj</strong> )</p>
<h5 id="导入ReactiveCocoa-xcodeproj-1"><a href="#导入ReactiveCocoa-xcodeproj-1" class="headerlink" title="导入ReactiveCocoa.xcodeproj"></a>导入ReactiveCocoa.xcodeproj</h5><p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/xcode7-3-1.gif" alt="导入ReactiveCocoa"></p>
<h5 id="导入Reuslt-xcodeproj-1"><a href="#导入Reuslt-xcodeproj-1" class="headerlink" title="导入Reuslt.xcodeproj"></a>导入Reuslt.xcodeproj</h5><p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/xcode7-3-1%E5%AF%BC%E5%85%A5Result.gif" alt="导入Result"></p>
<h3 id="工程目录的-“General”-的-“Embedded-Binaries”添加Framework"><a href="#工程目录的-“General”-的-“Embedded-Binaries”添加Framework" class="headerlink" title="工程目录的 “General” 的 “Embedded Binaries”添加Framework"></a>工程目录的 “General” 的 “Embedded Binaries”添加Framework</h3><blockquote>
<p>注:这里因为一般是iOS开发因此举例导入都是iOS的Framework框架</p>
</blockquote>
<h4 id="Xcode-8-2"><a href="#Xcode-8-2" class="headerlink" title="Xcode 8"></a>Xcode 8</h4><p>分别引入 <strong>Result.framework</strong>, <strong>ReactiveCocoa.framework</strong>, <strong>ReactiveSwift.framework</strong></p>
<p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/%E5%AF%BC%E5%85%A5framework.gif" alt="添加三种Framework"></p>
<h4 id="Xcode-7-3-1-2"><a href="#Xcode-7-3-1-2" class="headerlink" title="Xcode 7.3.1"></a>Xcode 7.3.1</h4><p>分别引入 <strong>Result.framework</strong>, <strong>ReactiveCocoa.framework</strong></p>
<p><img src="http://od88oby20.bkt.clouddn.com/gif/rac/xcode7-3-1%E5%BC%95%E5%85%A5Framework.gif" alt="添加两种Framework"></p>
<p>引入Framework完成后, 编译完成如果没有错误, 该步骤完成。</p>
<h3 id="工程不包含Swift代码-设置EMBEDDED-CONTENT-CONTAINS-SWIFT"><a href="#工程不包含Swift代码-设置EMBEDDED-CONTENT-CONTAINS-SWIFT" class="headerlink" title="工程不包含Swift代码, 设置EMBEDDED_CONTENT_CONTAINS_SWIFT"></a>工程不包含Swift代码, 设置EMBEDDED_CONTENT_CONTAINS_SWIFT</h3><p>设置 <strong>Bulid Settings</strong> 中的 <strong>EMBEDDED_CONTENT_CONTAINS_SWIFT</strong> 为 <strong>YES</strong></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>上述几步完成后, 引入 ReactiveCocoa 框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</div></pre></td></tr></table></figure>
<p>编译, 运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">RACSignal *singal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:@&quot;1111&quot;];</div><div class="line">    return nil;</div><div class="line">&#125;];</div><div class="line">[singal subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>查看打印结果, 如果是 1111 , 证明框架导入成功。</p>
<h2 id="CocoaPods引入"><a href="#CocoaPods引入" class="headerlink" title="CocoaPods引入"></a>CocoaPods引入</h2><p>使用 <strong>CocoaPods</strong> 引入时, 其实相对于手动导入就简单很多。</p>
<p>首先, 在引入 <strong>ReactiveCocoa</strong> 之前, 先来看看 <strong>RAC</strong> 最低支持的 <strong>iOS</strong> 版本是多少。<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/%E6%9C%80%E4%BD%8E%E6%94%AF%E6%8C%81%E7%9A%84%E7%89%88%E6%9C%AC.png" alt="RAC的支持的版本"></p>
<p>明确了最低支持的版本, 在需要使用 <strong>CocoaPods</strong> 的工程中创建 <strong>Podfile</strong> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure>
<p>然后使用如下命令打开 <strong>Podfile</strong> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open -a Xcode Podfile</div></pre></td></tr></table></figure>
<p>打开后的界面如下图:<br><img src="http://od88oby20.bkt.clouddn.com/img/rac/Podfile.png" alt=""></p>
<h2 id="Carthage引入"><a href="#Carthage引入" class="headerlink" title="Carthage引入"></a>Carthage引入</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveCocoa教程 - 入门：1/2]]></title>
      <url>http://muluochenxi.com/2016/09/06/ReactiveCocoa%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8%EF%BC%9A1-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>注意: 此文只是自己翻译学习，如有不对地方还望指出。此文结合如下俩篇文章翻译，一则练习自己的翻译能力，二则真正理解该文章。<br>个人感悟：<strong>自己动手写一遍，与浏览一遍，绝对是不一样的</strong><br><a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">原文链接</a><br><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1" target="_blank" rel="external">已有翻译文章</a></p>
</blockquote>
<p>作为一名iOS开发者, 你写的每一行代码几乎都是对某些事件的反馈:点击button、接收到网络信息、 一个属性的改变(通过KVO监测) 或者 通过CoreLocation监听用户所在位置的变化 以上等等都是很好的例子。然而，这些事件都有不同的编码方式，如: <strong>action、delegate、KVO、回调</strong>等。<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>为事件定义了标准的接口，从而可以使用一些基本工具来更容易的连接、过滤和组合。</p>
<p>听起来很困惑？奇妙？…令人兴奋？接着往下看:<br>ReactiveCocoa结合了几个编程风格:</p>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">Functional Programming</a> : 函数式编程, 使用了高阶函数，即函数采用了多种函数为它们的参数</li>
<li><a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="external">Reactive Programming</a> : 响应式编程，侧重数据流和变化传递</li>
</ul>
</blockquote>
<p>出于这个原因，你可能会听到ReactiveCocoa被描述为一个 <strong>函数响应式编程</strong> (<strong>FRP</strong>)框架。</p>
<p>放心，这个技术会在本教程中Get到！编程范式是一个不错的讨论主题，但这个ReactiveCocoa教程是一个实际的例子，而不是学术理论。</p>
<h2 id="The-Reactive-Playground"><a href="#The-Reactive-Playground" class="headerlink" title="The Reactive Playground"></a>The Reactive Playground</h2><p>在这个Reactive教程中，你将在一个非常简单的事例应用中引入响应式编程。下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="external">示例项目</a>，然后编译运行以保证已经拥有基本设置。(<a href="https://github.com/QC-L/ReactivePlayground/tree/master" target="_blank" rel="external">根据示例项目我也模仿编写一个Demo</a>)</p>
<p>ReactivePlayground是一个非常简单的应用程序，提供了一个登录界面。当用户输入正确的用户名和密码时，一只可爱的小猫就会映入眼帘。</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/1.png" alt="登录页面"><br><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/2.png" alt="登录成功后的页面"></p>
<p>现在来花时间看看这个简单Demo的代码。很简单，浪费多长时间。</p>
<p>打开 <strong>ViewController.m</strong>，全局的翻阅一下。你能否快速定位到 <strong>SignIn</strong> 的enabled状态? 能否快速找到 <strong>signInFailureLabel</strong> 什么时候显示/隐藏? 在这个相对简单的例子中可能只需要2-3分钟来回答这个问题。对于复杂的例子，如果是相同类型的，则需要花费相当长的时间。</p>
<p>使用ReactiveCocoa会让应用程序的的逻辑编的简洁。接下来开始使用。</p>
<h2 id="添加ReactiveCocoa框架依赖"><a href="#添加ReactiveCocoa框架依赖" class="headerlink" title="添加ReactiveCocoa框架依赖"></a>添加ReactiveCocoa框架依赖</h2><p>添加ReactiveCocoa最简单的方式就是使用 <a href="https://cocoapods.org/" target="_blank" rel="external"><strong>CocoaPods</strong></a> 如果你没用过CocoaPods，请先去看看 <a href="http://www.raywenderlich.com/97014" target="_blank" rel="external">CocoaPods简介</a> 这篇文章(或参照<a href="http://www.jianshu.com/p/44c894b69cf6" target="_blank" rel="external">CocoaPods的安装和使用(一)</a>)。 至少通过文章中的步骤将CocoaPods初始化完成，你才能安装ReactiveCocoa。</p>
<blockquote>
<p>如果由于某种原因你不想使用CocoaPods你仍然可以使用ReactiveCocoa，只需按照GitHub上的文档中的 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa#importing-reactivecocoa" target="_blank" rel="external"><strong>导入ReactiveCocoa步骤</strong></a>。<br>详细的手导入步骤不在这里做详细赘述, 建议去看关于<a href="">ReactiveCocoa手动导入的教程</a>。</p>
</blockquote>
<p>对于RAC，个人建议还是使用CocoaPods导入。</p>
<blockquote>
<p>打开 Terminal(终端) 进到工程目录<br>$ pod init<br>$ open -a Xcode Podfile</p>
</blockquote>
<p>在Podfile中添加 pod ‘ReactiveCocoa’, ‘~&gt; 4.0.4-alpha-4’ 框架</p>
<blockquote>
<p>注意: Swift文件使用CocoaPods导入, 需要加 <strong>use_frameworks!</strong><br>因此将Podfile中的 <strong>use_frameworks!</strong>取消注释</p>
</blockquote>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/3.png" alt="ReactiveCocoa导入"></p>
<blockquote>
<p>然后执行下载过程<br>$ pod install –verbose –no-repo-update</p>
</blockquote>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/4.png" alt="导入完成后的工程目录"></p>
<h2 id="Time-To-Play"><a href="#Time-To-Play" class="headerlink" title="Time To Play"></a>Time To Play</h2><p>正如介绍中提到的，ReactiveCocoa为处理您的应用程序中发生的事件的不同流的标准接口。在ReactiveCocoa术语，这些被称为信号，并且由RACSignal类表示。</p>
<p>打开应用的初始的视图控制器， ViewController.m，并在头部引入ReactiveCocoa的头文件。</p>
<blockquote>
<p>#import <reactivecocoa reactivecocoa.h=""></reactivecocoa></p>
</blockquote>
<p>暂时不要修改ViewDidLoad中其他的代码，在ViewDidLoad的末尾添加一些方法，随便做一些测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self.userNameText.rac_textSignal subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>编译并运行程序, 在用户名的输入框中，输入内容，查看控制台打印结果：</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/5.png" alt="控制台打印结果"></p>
<p>从上面的打印结果，你可以看出每次修改textfield中的文本时, 该Block块中的代码都会执行。没有target-action, 没有delegate, 只有信号和blocks。</p>
<p>ReactiveCocoa信号（由<strong>RACSignal</strong>表示）发送事件流给他们的用户。有三种类型的事件知道：next，error和completed。在出现<strong>error</strong>或者信号<strong>completed</strong>之前, 一个信号能送任意数量的事件。在本节中，你会专注于<strong>next event</strong>。请务必阅读第二部分时，它可用来了解error和completed的事件。</p>
<p><strong>RACSignal</strong>包含很多方法，用于订阅这些不同的事件类型。每个方法都需要一个或多个Block，当事件发生时，在你Block中的逻辑则会执行。在这种情况下，可以看出 <strong>subscribeNext:</strong> 方法被用于提供一个Block给每一个将要执行的 <strong>next event</strong>。<br>ReactiveCocoa 框架使用了许多Category给UIKit框架中的一些基本控件添加了许多信号的方法，因此你可以订阅他们的事件。这就是textfield属性中rac_textSingal的来源。</p>
<p>原理就介绍到这里，接下来开始使用ReactiveCocoa去为你做一些事情。</p>
<p>ReactiveCocoa有许多操作，你可以用它们来操纵事件流。例如，你只让3个字符以上的用户名有效。你可以实现 <strong>filter</strong>(过滤) 这个操作。在之前的ViewDidLoad添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[self.userNameText.rac_textSignal filter:^BOOL(id value) &#123;</div><div class="line">    NSString *text = value;</div><div class="line">    return text.length &gt; 3;</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>运行之后，然后键入一些文本到textField，你会发现。他只会打印textField长度大于3的字符串。<br><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/监听图.gif" alt="监听图.gif"></p>
<p>你在这里创建了一个非常简单的事件流。它就是反应式编程的本质，通过数据流来表达应用程序的功能。</p>
<p>下面这张图片可以帮助你更好的理解数据流向：</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/FilterPipeline.png" alt="filter 过滤数据流"></p>
<p>从上面的图中可以看出，rac_textSignal是事件的最初来源。数据流通过过滤器时，仅允许字符串的长度是大于三的事件进传递。在事件流的最后一步是 <strong>subscribeNext:</strong> 在这里你可以打印事件的值。</p>
<p>值得一提的一点是，该filter过滤器的返回值也是一个RACSignal(即返回值为一个信号)。你可以通过如下分步代码来理解数据流向的具体步骤:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RACSignal *signal = self.userNameText.rac_textSignal;</div><div class="line">RACSignal *filterSignal = [signal filter:^BOOL(id value) &#123;</div><div class="line">     NSString *text = value;</div><div class="line">     return text.length &gt; 3;</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">[filterSignal subscribeNext:^(id x) &#123;</div><div class="line">     NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>一个RACSignal的每个操作的返回值也是RACSignal，因此，它被称为 <strong>流式接口</strong> (<a href="http://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="external">fluent interface</a>)。这样的特征允许你构建事件流，而不需要考虑每一步都使用局部变量。</p>
<blockquote>
<p>注意: ReactiveCocoa使用了大量的Block。如果你新学习Block，你可能需要阅读苹果官方的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank" rel="external">Blocks Programming Topics</a>。而如果像我一样，已经熟悉了Blocks，但却发现很难记住，你可以去看看很有趣的一个网站<a href="http://goshdarnblocksyntax.com/" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a> (经测试该链接是正常运作的)</p>
</blockquote>
<h2 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h2><p>刚刚我们将之前的代码分割成了多个RACSignal，那现在将其改回之前的流式语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[self.userNameText.rac_textSignal filter:^BOOL(id value) &#123;</div><div class="line">    NSString *text = value;// 隐式转换</div><div class="line">    return text.length &gt; 3;</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>在上面的代码中, 注释部分从id隐式转换成NSString，这样看起来不是很优雅。幸运的是，传递给该Block中的值就是一个NSString，你可以更改参数类型本身。更新你的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[self.userNameText.rac_textSignal filter:^BOOL(NSString *text) &#123;</div><div class="line">    return text.length &gt; 3;</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>编译并运行，确保没有任何问题。</p>
<h2 id="什么是一个事件？"><a href="#什么是一个事件？" class="headerlink" title="什么是一个事件？"></a>什么是一个事件？</h2><p>到目前为止，本教程描述了不同的事件类型，但并没有详细说明这些事件的结构。有趣的是，一个事件绝对可以包含任何事情！</p>
<p>通过下面这个例子，你可以将另一个操作添加到事件流。添加如下代码到你的ViewDidLoad:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[[[self.userNameText.rac_textSignal map:^id(NSString *text) &#123;</div><div class="line">    return @(text.length);</div><div class="line">&#125;] filter:^BOOL(NSNumber *value) &#123;</div><div class="line">    return [value integerValue] &gt; 3;</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>如果你编译运行，你会发现打印的是文本的长度：</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/map.gif" alt="map.gif"><br>新添加的map(映射)操作为改变事件数据提供了Block块。它将接收到的事件，通过执行Block块所得的返回值提供给下一个事件。在上面的代码中，map的Block返回了取出的NSString文字的长度, 这使得下一个事件的值则为NSNumber类型。</p>
<p>对于它如何工作的请看下面这张图片:</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/FilterAndMapPipeline.png" alt="Filter And Map"></p>
<p>正如你所看到的一样，所有这一切跟着map的操作进行改变, 现在接收到的是NSNumber类型的对象。你可以使用 map 操作去将你接收到的数据转换成你喜欢的类型, 只要他是一个对象类型。</p>
<blockquote>
<p>注意: 在上面的例子中text.length属性的类型是NSUInteger。为了用它作为事件的内容，它必须被装箱。幸运的是Objective-C的文字语法中提供了字面量 - @(text.length)。</p>
</blockquote>
<p>这些足够开始编写代码了! 现在是时候使用目前学到的概念更新ReactivePlayground应用程序。现在你可以删除所有已经添加的代码了。</p>
<h2 id="创建有效状态的Signals-信号"><a href="#创建有效状态的Signals-信号" class="headerlink" title="创建有效状态的Signals(信号)"></a>创建有效状态的Signals(信号)</h2><p>首先，先创建俩个信号, 表示用户名密码是否有效。添加以下内容到ViewController.m中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RACSignal *validUsernameSignal = [self.userNameText.rac_textSignal</div><div class="line">     map:^id(NSString *text) &#123;</div><div class="line">         return @([self isValidUsername:text]); </div><div class="line">&#125;];</div><div class="line">    </div><div class="line">RACSignal *validPasswordSignal = [self.passWordText.rac_textSignal</div><div class="line">     map:^id(NSString *text) &#123;</div><div class="line">         return @([self isValidPassword:text]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>正如你所看到的, 上述代码通过map函数将 <strong>rac_textSignal</strong> 所生成的字符串类型的值转换为了 <strong>NSNumber</strong> 类型的 <strong>BOOL</strong> 值。</p>
<p>接下来, 转变信号时，可以给textField提供相应的背景颜色。简单来说，就是你订阅这个信号并使用信号的结果来更新textFiled的背景颜色。你可以像下面这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> [[validPasswordSignal map:^id(NSNumber *passwordValid) &#123;</div><div class="line">        return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line"> &#125;] subscribeNext:^(UIColor *color) &#123;</div><div class="line">        self.passWordText.backgroundColor = color;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>(<strong>请不要添加这段代码到你的工程中, 因为还有更优雅的方案!</strong>)</p>
<p>理论上指派的信号输出的值会改变textField的backgroundColor属性。然而，这段代码的方案是比较low的。</p>
<p>幸运的是, ReactiveCocoa有一个宏, 可以将这段代码表现的更优雅。在viewDidLoad中添加俩个信号, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RAC(self.userNameText, backgroundColor) = [validUsernameSignal map:^id(NSNumber *usernameValid) &#123;</div><div class="line">        return [usernameValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">&#125;];</div><div class="line">RAC(self.passWordText, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid) &#123;</div><div class="line">        return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p><strong>RAC</strong>的宏会将信号输出的值赋给对象的属性。它包含俩个参数，参数一 : 需要设置的属性值的对象， 参数二 : 要赋值的属性名称。每个信号发送下一个事件时, 传递的值就会被赋给指定的属性。</p>
<p>这是一个非常优雅的解决方案，你认为呢？</p>
<p>在你编译和运行之前，做最后一件事。找到<strong>updateUIState</strong>方法并删除掉以下俩行内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.userNameText.backgroundColor = self.usernameIsValid ? [UIColor whiteColor] : [UIColor yellowColor];</div><div class="line">self.passWordText.backgroundColor = self.passwordIsValid ? [UIColor whiteColor] : [UIColor yellowColor];</div></pre></td></tr></table></figure></p>
<p>这样就清除掉了非RAC的代码。</p>
<p>编译并运行应用程序。你会发现textField的内容在无效时，是高亮的；在有效时，是透明的。</p>
<p>看起来效果不错，如果当前的逻辑以图形化来表示的话，如下图。在下面你可以看到把俩个信号形容成俩个通道，俩个通道做了相同的事情。首先，信号通过map方法映射成判断是否有效的BOOL值，再通过map方法通过二次映射将BOOL值转成UIColor，通过UIColor决定textField的背景颜色。</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/TextFieldValidPipeline.png" alt="二次映射 map.png"></p>
<p>看到这里，你是否有疑问为何要创建俩个独立的validPasswordSignal和validUsernameSignal信号，而不是俩个输入框公用一个信号呢？想知道答案，接着往下看！</p>
<h2 id="信号结合"><a href="#信号结合" class="headerlink" title="信号结合"></a>信号结合</h2><p>在当前这个App中，登录按钮在用户名输入框和密码输入框都有效时, 才被显示。现在是时候改成 <strong>响应式</strong> 了!</p>
<p>当前的代码已经具有判断用户名和密码字段是否有效的功能，并且是一个可以返回BOOL类型值的信号; 分别是 <strong>validUsernameSignal</strong> 和 <strong>validPasswordSignal</strong>。接下来的任务就是将这俩个信号结合在一起来决定button是否可以点击。</p>
<p>在viewDidLoad的末尾处添加如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RACSignal *signUpActiveSignal =</div><div class="line">[RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</div><div class="line">        return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>上面的代码使用了<strong>combineLatest: reduce:</strong> 方法, 通过结合validUsernameSignal 和 validPasswordSignal所发出的结果，从而生成一个新的信号。每次当这俩个源信号中任意一个值改变时, <strong>reduce block</strong>会执行, 并将俩个源信号的值<strong>组合</strong>作为新的信号的返回值。</p>
<blockquote>
<p>注意: RACSignal的 combinLatest 方法能结合任意数量的信号， 并且<strong>reduce block</strong>中的每一个参数都是对应源信号的(combinLatest中的信号顺序, 与参数顺序相同)。<br>ReactiveCocoa中包含一个实用的工具类, <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoa/Objective-C/RACBlockTrampoline.h" target="_blank" rel="external">RACBlockTrampoline</a>可以在内部处理<strong>reduce block</strong>内部变量参数列表。事实上, 有很多隐藏在ReactiveCocoa实现中的实用的小技巧，非常值得你去学习研究。</p>
</blockquote>
<p>现在你有一个非常合适的信号添加到viewDidLoad结尾处。将这个信号与Button的enabled属性绑定在一起:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</div><div class="line">    self.signIn.enabled = [signupActive boolValue];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>在运行代码之前，我们需要花点时间来删除一些没用的代码。删除文件顶部的下面俩个属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) BOOL passwordIsValid;</div><div class="line">@property (nonatomic, assign) BOOL usernameIsValid;</div></pre></td></tr></table></figure></p>
<p>从最接近viewDidLoad顶部的位置， 移除掉以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[self.userNameText addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged];</div><div class="line">[self.passWordText addTarget:self action:@selector(passwordTextFieldChanged) forControlEvents:UIControlEventEditingChanged];</div></pre></td></tr></table></figure></p>
<p>还需要删除 updateUIState, usernameTextFieldChanged和passwordTextFieldChanged方法。</p>
<p>最后，确保从viewDidLoad中删除updateUIState方法的调用。</p>
<p>如果你编译运行，检查登录按钮的状态。如果按钮是可用的，说明userNameText和passWordText都是有效状态。和以前的效果一样。</p>
<p>更新应用程序逻辑后，执行流程如下图:<br><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/CombinePipeline.png" alt="执行流程.png"></p>
<p>以上说明了几个非常重要的概念，可以使用ReactiveCocoa去执行一些非常重量级的任务</p>
<blockquote>
<ul>
<li>拆分 - 信号可以有多个订阅者，也可以作为多个后续事件流步骤的源。另外，在上图中，请注意指示userNameText和passWordText是否有效的信号，被分别用于了不同的地方。</li>
<li>聚合 - 多个信号可以被组合，以用来创建新的信号。在这种情况下，俩个BOOL信号用做合并。然而，你可以通过结合信号发出任意值类型的信号。</li>
</ul>
</blockquote>
<p>这些改变的结果是应用程序不用再写私有属性用来表明俩个textField的当前有效状态。你会发现，这是你采用响应式编程与以往模式主要不同的地方之一 —  你不需要使用实例变量来追踪瞬时的状态。</p>
<h2 id="响应式登录"><a href="#响应式登录" class="headerlink" title="响应式登录"></a>响应式登录</h2><p>该应用目前使用如上图所示的响应式事件流来管理文本框和按钮的状态。不过，按下按钮操作仍然在使用action做响应，所以下一步是使用 <strong>响应式</strong> 更换剩下的应用程序的逻辑。</p>
<p>在ViewController.m中, SignIn按钮的Touch Up Inside事件通过StoryBoard与signInTouchUp方法进行关联。如果过你想用响应式替代，首先你需要先断开当前故事版与action的连线。</p>
<p>打开Main.storyboard, 找到Sign In按钮, 按住Ctrl键单击按钮，会弹出outlet/action连接的界面，找到对应的action连接，点击x删除掉对应的连接。下图很直观的显示出来在哪里可以删除按钮的action:</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/删除登陆按钮事件.png" alt="删除登录按钮事件.png"></p>
<p>你已经看到了ReactiveCocoa框架为标准的<strong>UIKit</strong>框架的<strong>controls</strong>添加了属性和方法。到现在为止，我们已经使用了rac_textSignal, 发射事件时，文本的变化。为了更好的处理事件，你需要使用ReactiveCocoa中其他的给UIKit添加的controls中的方法— rac_signalForControlEvents。</p>
<p>回到ViewController.m中, 在viewDidLoad结尾处添加如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[self.signIn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</div><div class="line">        NSLog(@&quot;button clicked&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>上述代码通过创建一个按钮的<strong>UIControlEventTouchUpInside</strong>事件信号, 并对该信号进行订阅，使每个这个事件被触发生时，都有Log。</p>
<p>编译运行，验证是否与我们所想象的那样一致，会出现消息Log。注意，确保用户名和密码都是有效时, 按钮才可以点击。所以在点击按钮之前，先输入一些文字到俩个textField中。</p>
<p>输入完毕，按钮有效后。点击几次按钮，你可以看到Xcode控制台中会出现如下打印信息:<br><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/6.png" alt="点击时触发的打印效果"></p>
<p>现在，这个按钮已经具有点击触发事件的信号。下一步就是把该事件与登录流程组合起来。这就出现了问题-但这是好的。打开ReactiveManager.h，看看内部的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 实际项目可根据请求结果决定</div><div class="line">typedef void(^SignInResponse)(BOOL);</div><div class="line">@interface ReactiveManager : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> *  登录的方法</div><div class="line"> *</div><div class="line"> *  @param username      用户名</div><div class="line"> *  @param password      密码</div><div class="line"> *  @param completeBlock 登录成功后的回调</div><div class="line"> */</div><div class="line">+ (void)signInWithUsername:(NSString *)username</div><div class="line">                  password:(NSString *)password</div><div class="line">                  complete:(SignInResponse)completeBlock;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>该服务需要用户名，密码和完成的 <strong>Block</strong> 作为参数。当登录成功或失败时，<strong>Block</strong> 会执行。你可以在按钮点击事件 <strong>subscribeNext:</strong> 的 <strong>Blcok</strong> 里直接调用这个方法，但是这么做会有些不合适。你可以直接使用 <strong>ReactiveCocoa</strong> 来重写这些代码。</p>
<blockquote>
<p>注意: 本教程依赖的是一个虚拟的服务，这样并没有对外界的API产生依赖。但是，遇到了新的问题，如何在信号中表示不是用信号编写的API。</p>
</blockquote>
<h2 id="创建信号"><a href="#创建信号" class="headerlink" title="创建信号"></a>创建信号</h2><p>幸运的是，把一个现有的异步API表示为一个信号还是很简单的。首先，从ViewController.m中删除当前signInButtonTouched方法。已经不需要这个逻辑了，因为会有与之等价的方法来替换它。</p>
<p>然后在ViewController.m中添加以下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signInSignal &#123;</div><div class="line">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        [ReactiveManager signInWithUsername:self.userNameText.text password:self.passWordText.text complete:^(BOOL success) &#123;</div><div class="line">             [subscriber sendNext:@(success)];</div><div class="line">             [subscriber sendCompleted];</div><div class="line">         &#125;];</div><div class="line">        return nil;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方法，创建了一个使用用户名和密码登录的信号。现在我们拆分来看看。</p>
<p>上面的代码使用了 <strong>RACSignal</strong> 信号的 <strong>createSignal:</strong>  的方法。描述这个信号模块的是一个 <strong>Block</strong> 。当这个信号有订阅者时，会执行此 <strong>Block</strong> 内的代码。</p>
<p>该Block的参数是一个遵循 <strong>RACSubscriber</strong> 协议的 <strong>subscriber</strong>，协议中有很多方法可以产生事件。你还可以发送任意数量的 <strong>next</strong> 事件，当调用 <strong>error</strong> 或是 <strong>complete</strong> 时则会被终止。在本案例中，首先发送了一个 <strong>next</strong> 事件来指示登录是否成功，然后发送了一个 <strong>complete</strong> 的事件。 </p>
<p>这个Block的返回类型是 <strong>RACDisposable</strong> 对象, 它可以让你执行你所需要的清理工作，例如取消订阅或丢弃。这个信号并不需要清理任何内容，因此，返回 <strong>nil</strong>。</p>
<p>正如你所看到的，这是多么简单的一个封装异步API的信号。</p>
<p>接下来，让我们利用这一信号。更新您添加到ViewDidLoad中末尾的代码，如下所示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[self.signIn rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) &#123;</div><div class="line">      return [self signInSignal];</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">      NSLog(@&quot;Sign in result: %@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上述代码使用先前的按钮触摸信号并通过 map(映射) 转换成登录信号。用户只需要登录的结果。</p>
<p>编译运行后，点击登录按钮，查看Xcode的控制台，你会看到上面代码的结果……</p>
<p>……并且结果和你预期的并不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-03-28 21:44:06.713 ReactivePlayground[2956:83740] Sign in result: &lt;RACDynamicSignal: 0x7fa7fbcb8a80&gt; name:</div></pre></td></tr></table></figure>
<p>该信号已经执行了 subscribeNext： Block, 但是登录信号的输出结果与我们想要的并不一样!</p>
<p>通过下图可以告诉你，究竟哪里错了:</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/SignalOfSignals.png" alt="信号转变.png"></p>
<p>当你点击按钮时,  <strong>rac_signalForControlEvents</strong> 会发出 <strong>next</strong> 事件。<strong>map(映射)</strong> 会创建并返回登录信号, 这意味着事件流的下一步会接收到 <strong>RACSignal</strong> 信号。这就是为什么后面打印出来的是信号，而不是我们想要的结果。</p>
<p>以上情况也有时会被称为信号的信号；换句话说，一个外信号内包含了一个内信号。你可以中外部信号 <strong>subscribeNext: </strong> 的Block中再订阅信号，但是这样会造成混乱。幸运的是，ReactiveCocoa为这种常见的情况准备了应对方案。</p>
<h2 id="信号的信号"><a href="#信号的信号" class="headerlink" title="信号的信号"></a>信号的信号</h2><p>要解决这个问题很简单，只要修改 <strong>map(映射)</strong> 函数改为 flattenMap函数, 如下图所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[[self.signIn rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) &#123;</div><div class="line">      return [self signInSignal];</div><div class="line">&#125;] subscribeNext:^(id x) &#123;</div><div class="line">      NSLog(@&quot;Sign in result: %@&quot;, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>此按钮触摸事件转换为了登录信号，并且通过内部信号向外部信号发送了正确的结果。</p>
<blockquote>
<p>map 映射出的值是 信号本身<br>    flattenMap 映射出的值是 信号的值</p>
</blockquote>
<p>编译运行，看控制台结果，现在应该输出登录成功或者失败了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-03-29 15:53:25.639 ReactivePlayground[5861:233703] Sign in result: 0</div><div class="line">2016-03-29 15:53:33.791 ReactivePlayground[5861:233703] Sign in result: 1</div></pre></td></tr></table></figure>
<p>现在可以做你想做的事了，最后一步就是将登录是否成功逻辑添加到 <strong>subscribeNext</strong> 中，用以下代码把刚刚的代码替换掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[[self.signIn rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^id(id x) &#123;</div><div class="line">    return [self signInSignal];</div><div class="line">&#125;] subscribeNext:^(NSNumber *signedIn) &#123;</div><div class="line">    BOOL success = [signedIn boolValue];</div><div class="line">    self.signInFailureLabel.hidden = success;</div><div class="line">    if (success) &#123;</div><div class="line">          [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>通过 subscribeNext: Block取到结果，通过该结果更新signInFailureLabel的可见性，并根据结果来决定是否要执行 segue 的跳转。</p>
<p>编译运行，我们再次看到了那只可爱的小猫。</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/final.png" alt="LoginSuccess"></p>
<p>就现在的应用体验而言，你有没有发什么什么不好的用户体验？当登录服务正在进行时, 应该禁用登录按钮。这可以避免用户重复登录。此外，如果登录失败了一次，显示了错误提示，应当再用户视图登录时隐藏掉。</p>
<p>但是，问题来了，应该如何添加这个逻辑到当前代码中呢？更改按钮的启用状态，无法使用 map filter 或其他已知的概念。这就可以称之为 <strong>附加操作</strong> 了，因为这个逻辑应该在next事件发生时执行，并不是改变事件本身。</p>
<h2 id="附加操作"><a href="#附加操作" class="headerlink" title="附加操作"></a>附加操作</h2><p>用以下代码替换之前所写代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[[[[self.signIn rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(id x) &#123;</div><div class="line">    self.signIn.enabled = NO;</div><div class="line">    self.signInFailureLabel.hidden = YES;</div><div class="line">&#125;] flattenMap:^id(id x) &#123;</div><div class="line">    return [self signInSignal];</div><div class="line">&#125;] subscribeNext:^(NSNumber *signedIn) &#123;</div><div class="line">    self.signIn.enabled = YES;</div><div class="line">    BOOL success = [signedIn boolValue];</div><div class="line">    self.signInFailureLabel.hidden = success;</div><div class="line">    if (success) &#123;</div><div class="line">       [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>你可以看到上面代码添加了一个 <strong>doNext:</strong> , 在触摸事件后添加的。请注意, doNext:并没有返回值, 因为它只是一个附加操作，并且事件本身不变。</p>
<p>在doNext Block中设置登录按钮不可点击，并隐藏了 signInFailureLabel。并在 subscribeNext: Block中重新启用 登录按钮，并根据结果决定是否显示失败文本。</p>
<p>现在是时候更新程序执行示意图，包括附加操作：</p>
<p><img src="http://blog.muluochenxi.com/img/ReactiveCocoa/doNext.png" alt="doNext附加操作"></p>
<p>编译运行，并确认按钮启用是否与预期相同。</p>
<p>如果和你想的一样，那么这个应用就大功告成了。</p>
<p>如果你在之前没有跟上，可以通过这个地址下载<a href="https://github.com/QC-L/FinalReactivePlayground" target="_blank" rel="external">最终的项目</a></p>
<blockquote>
<p>注意: 在异步执行的过程中禁用按钮是一个常见问题，ReactiveCocoa也能作出很好的解决。RACCommand就封装了这个概念，它有个enabled信号，使您可以将信号和enabled连接起来，你也可以试试这个类。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望本教程可以在你自己的应用程序中使用ReactiveCocoa时给你一个良好的基础。你可以采取一些练习来熟悉这些概念，就像学习一门编程语言或编程一样，一旦你有了良好的基础，它就变得很简单。ReactiveCocoa中的核心就是信号，无非就是一堆事件流。还有什么能比这个更简单呢？</p>
<p>随着逐渐学习ReactiveCocoa，我发现了其中有可以解决很多疑难问题的方法。你可以使用本教程案例试试，调整信号的组合和拆分。</p>
<p>这里最值得注意的是ReactiveCocoa的主要目标是使你的代码更加简洁，更加容易理解。如果应用程序的逻辑都清晰的表示成事件流、流式语法，那这个应用具体做了什么就很好理解了。</p>
<p>在本教程系列的第二部分，你将学习更先进的语法。比如错误处理以及如何管理不同线程中执行的代码等高级语法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking3.0]]></title>
      <url>http://muluochenxi.com/2016/09/06/AFNetworking3-0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>AFNetworking是一款在OS X和iOS下都令人喜爱的网络库。为了迎合iOS新版本的升级, AFNetworking在3.0版本中删除了基于 <del><strong>NSURLConnection</strong></del> API的所有支持。如果你的项目以前使用过这些API，建议您立即升级到基于 <strong>NSURLSession</strong> 的API的AFNetworking的版本。本指南将引导您完成这个过程。</p>
</blockquote>
<p>本指南是为了引导使用AFNetworking 2.x升级到最新的版本API，以达到过渡的目的，并且解释了新增和更改的设计结构。</p>
<h2 id="新设备要求-iOS-7-Mac-OS-X-10-9-watchOS-2-tvOS-9-amp-Xcode-7"><a href="#新设备要求-iOS-7-Mac-OS-X-10-9-watchOS-2-tvOS-9-amp-Xcode-7" class="headerlink" title="新设备要求: iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7"></a>新设备要求: iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7</h2><p>AFNetworking 3.0正式支持的iOS 7， Mac OS X的10.9， watchOS 2 ， tvOS 9 和Xcode 7。如果你想使用AFNetworking在针对较旧版本的SDK项目，请检查<a href="https://github.com/AFNetworking/AFNetworking/blob/master/README.md#requirements" target="_blank" rel="external">README</a>的兼容性信息。</p>
<h2 id="NSURLConnection的API已废弃"><a href="#NSURLConnection的API已废弃" class="headerlink" title="NSURLConnection的API已废弃"></a>NSURLConnection的API已废弃</h2><p>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。</p>
<p>AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p>
<h2 id="弃用的类"><a href="#弃用的类" class="headerlink" title="弃用的类"></a>弃用的类</h2><p>下面的类已从AFNetworking 3.0中废弃：</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<h2 id="修改的类"><a href="#修改的类" class="headerlink" title="修改的类"></a>修改的类</h2><p>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构:</p>
<ul>
<li>UIImageView+AFNetworking</li>
<li>UIWebView+AFNetworking</li>
<li>UIButton+AFNetworking</li>
</ul>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><hr>
<h4 id="AFHTTPRequestOperationManager-核心代码"><a href="#AFHTTPRequestOperationManager-核心代码" class="headerlink" title="AFHTTPRequestOperationManager 核心代码"></a>AFHTTPRequestOperationManager 核心代码</h4><p>如果你以前使用 <strong>AFHTTPRequestOperationManager</strong> ， 你将需要迁移去使用 <strong>AFHTTPSessionManager</strong>。 以下的类在两者过渡间并没有变化：</p>
<ul>
<li>securityPolicy</li>
<li>requestSerializer</li>
<li>responseSerializer</li>
</ul>
<p>接下来举一个关于AFHTTPSessionManager的简单例子。<strong>注意</strong>HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</p>
<h5 id="AFNetworking-2-x"><a href="#AFNetworking-2-x" class="headerlink" title="AFNetworking 2.x"></a>AFNetworking 2.x</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">[manager GET:@&quot;请求的url&quot; parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</div><div class="line">        NSLog(@&quot;成功&quot;);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, NSError*error) &#123;</div><div class="line">        NSLog(@&quot;失败&quot;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h5 id="AFNetworking-3-0"><a href="#AFNetworking-3-0" class="headerlink" title="AFNetworking 3.0"></a>AFNetworking 3.0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *session = [AFHTTPSessionManager manager];</div><div class="line">[session GET:@&quot;请求的url&quot; parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123;</div><div class="line">        NSLog(@&quot;成功&quot;);</div><div class="line">&#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123;</div><div class="line">        NSLog(@&quot;失败&quot;);        </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="AFHTTPRequestOperation-核心代码"><a href="#AFHTTPRequestOperation-核心代码" class="headerlink" title="AFHTTPRequestOperation 核心代码"></a>AFHTTPRequestOperation 核心代码</h4><p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。</p>
<p>在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。</p>
<p>接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。</p>
<h5 id="AFNetworking-2-x-1"><a href="#AFNetworking-2-x-1" class="headerlink" title="AFNetworking 2.x"></a>AFNetworking 2.x</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSURL *URL = [NSURL URLWithString:@&quot;&quot;];</div><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:URL];</div><div class="line">AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line">op.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</div><div class="line">        NSLog(@&quot;JSON: %@&quot;, responseObject);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;</div><div class="line">        NSLog(@&quot;Error: %@&quot;, error);</div><div class="line">&#125;];</div><div class="line">[[NSOperationQueue mainQueue] addOperation:op];</div></pre></td></tr></table></figure>
<h5 id="AFNetworking-3-0-1"><a href="#AFNetworking-3-0-1" class="headerlink" title="AFNetworking 3.0"></a>AFNetworking 3.0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSURL *URL = [NSURL URLWithString:@&quot;&quot;];</div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">[manager GET:URL.absoluteString parameters:nil success:^(NSURLSessionTask *task, id responseObject) &#123;</div><div class="line">        NSLog(@&quot;JSON: %@&quot;, responseObject);</div><div class="line">&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123;</div><div class="line">        NSLog(@&quot;Error: %@&quot;, error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="UIKit的迁移"><a href="#UIKit的迁移" class="headerlink" title="UIKit的迁移"></a>UIKit的迁移</h4><p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。</p>
<p>UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p>
<h4 id="UIAlertView的类目被废弃"><a href="#UIAlertView的类目被废弃" class="headerlink" title="UIAlertView的类目被废弃"></a>UIAlertView的类目被废弃</h4><p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
<p>原文链接: <a href="https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-3.0-Migration-Guide#new-requirements-ios-7-mac-os-x-109-watchos-2-tvos-9--xcode-7" target="_blank" rel="external">AFNetworking 3.0</a><br>纯属个人翻译，如有错误，还请纠正。</p>
]]></content>
    </entry>
    
  
  
</search>
